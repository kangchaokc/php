正则表达式就是描述了一类字符串的特征，通过这个特征与特定的函数配合使用，对其他字符串进行匹配	查找	替换	分割操作
	语法规则:
			这类字符串特征是由一个或多个
								1)普通字符(比如a到z)
								2元字符(有特殊功能的字符	比如:* + ?等)
								等组成的字符串
		例如:
			/a/		a就是普通字符		/是定界符(表示正则表达式的开始和结束)
		
		正则表达式除了字母	数字	反斜线以外多可以作为定界符比如
				#	！	{}	|	多可以	保持前后一致


	元字符:	--------------------------------------------------------------------------------------------
		.  *	叫贪婪匹配			.*?		叫懒惰匹配	
			\d						匹配任意【一个】十进制数字	等价于[0-9]
			\D						匹配任意【一个】除十进制数字以外字符	等价于[^0-9]
			\s						匹配任意【一个】空白字符	比如页符，换行符，回车符，制表符，垂直制表符
			\S						匹配出除空白符以外的任意【一个】字符
			\w						匹配任意【一个】数字或者字母或者下划线
			\W						匹配除数字	字符	下划线以外的任意【一个字符】
			.						匹配除换行符以外的任意【一个字符】
			
			*						匹配0次或者1次或者多次【前面的字符】
									放在*号前面的字符可以出现0次  1次     也可以出现多次
			+						匹配1次或者多次【前面的字符】	
			?						匹配0次或者1次【前面的字符】
			{n}						表示前面字符只能出现n次
			{n,}					表示前面字符>=n次
			{n,m}					表示前面字符>=n次	<=m次
			^或者\A					匹配字符串开始位置(最左边)必须包含这个字符
			$或者\Z					匹配字符串结束位置(最右边)必须包含这个字符
			|						匹配2个或多个
			[]						匹配方括号中的任意【一个】字符
			[^]						匹配除方括号中的字符以外任意【一个】字符
			
			()						再将括号中作为一个整体以便将其中的内容获取
			\\数字					表示第几个括号的内容		放在哪个地方哪个地方的字符必须与()
															里面字符一样才能匹配上例如
															$a='/t(e)st\\1/';//会有2个数组		teste		e
															$b="test";//这匹配不到
															$b="teste";//可以匹配


	模式修饰符:	修饰符可以多个配合使用------------------------------------------------------------------------
				
				i			不区分大小写
				m			多行匹配		如果目标中没有"\n"字符，正则表达式中没出现^或者$	设置这个修饰符不产生任何影响
										注意:如果目标中是手动用回车换行的 涉及到一个操作系统的问题
											$str="test
											test
											test";注意    字符串里面包含了\n要用""括起来		''没用
										//在Windows中看到的换行(现象)其实是同过2个字符来完成的(\r\n)
										相当于$str="test\r\ntest\r\ntest\r\ntest";
										//Linux中看到的换行(现象	就是在键盘上敲的回车键)通过\n来完成的	\r	回车符	\n	换行符
											兼容  可用		\r*
								
				s						如果设置了此字符	那么	.	将匹配所有字符	包括换行符(\n)		
												$a="/t.st/s";
												$b="t\nst";是可以的
												$b="t
												st";是不可以的  相当于$b="t\r\nst";		
												
				大写U							禁止贪婪匹配	$a="/a.*f/U";	等价于	$a="/a.*?f/";
															$B="   adsfsdggf   afodndjf    ";
				
				
					
				
	与正则表达式配合的函数:----------------------------------------------------------
			//执行一次正则表达式		相当于在一串字符里面能匹配多个的话      preg_match()只会从左往右匹配一个合格的  要么int0次  要么int1次
			//(可选)第4个参数的作用		返回正则表达式第一个字符在字符串里面的索引值位置int
			//(可选)第5个参数的作用		从第几个【字节】开始匹配
				preg_match($正则表达,$字符串,$用来存储匹配到的字符,PREG_PFFSET_CAPIURE)	
			
			
				//匹配字符串所有合格的字符
				//第4个参数作用	改变第3个参数存储的方式	
				//默认 PREG_PATTERN_OPDER
				//PREG_SET_PRDER
				//PREG_OFFSET_CAPTURE
				//第5个参数		从第几个字节开始匹配
			preg_match_all()	
			
			
			
			//替换
			//第一个参数		正则表达式
			//第二个参数		要替换的字符串
			//第三个参数		目标字符串
			//(可选)第4个参数		符合正则的字符串替换次数	默认-1(无限，全部替换)	0(不替换，没意义)		1(替换一次)
			//(可选)第5个参数		$名字	用来存储替换的次数  	不是数组是int值	替换一次是int1  替换全部是n次
			preg_replace($a,$b,$c,-1,$y)
							例如:
								$a='/<div>(.*?)<\/div>/';注意div里面的正斜杠	要转义	也可以用其他定界符
								$b="<a></a>";
								$c="sdfsf<div>测试多个的根深蒂固如果山东福建ddf的dfs</div>";
								这会连div标签里面的内容也会替换
									不要里面内容替换可以在$b用\\数字或者$数字	
										$a='/<div>(.*?)<\/div>/';注意div里面的正斜杠	要转义	也可以用其他定界符
										$b="<a>$1</a>";
										$c="sdfsf<div>测试多个的根深蒂固如果山东福建ddf的dfs</div>";	
											这样里面的内容就不会替换	
				preg_replace()第一个参数和第二个参数可以传数组:
														一一对应关系
													